# GoBuildSTL
> 本仓库收录个人在C++转Go语言过程中，使用go模拟C++STL容器以到达熟悉Go语言语法的目的。



# 目录结构

> 该目录为拟定目录，后续随开发进度等可能会有调整。

```go
GoBuildSTL/                # 项目根目录
├── src/                   # 源代码目录
│   ├── containers/        # 容器实现
│   │   ├── vector.go      # 动态数组实现 (类似于 C++ 的 std::vector)
│   │   ├── list.go        # 双向链表实现 (类似于 C++ 的 std::list)
│   │   ├── map.go         # 关联容器 (类似于 C++ 的 std::map)
│   │   ├── set.go         # 集合容器 (类似于 C++ 的 std::set)
│   │   └── deque.go       # 双端队列实现 (类似于 C++ 的 std::deque)
│   ├── iterators/         # 迭代器实现
│   │   ├── iterator.go    # 通用迭代器接口定义
│   │   ├── vector_iterator.go  # vector 迭代器实现
│   │   ├── list_iterator.go    # list 迭代器实现
│   │   └── map_iterator.go     # map 迭代器实现
│   ├── algorithms/        # 算法实现
│   │   ├── sort.go        # 排序算法 (类似于 std::sort)
│   │   ├── find.go        # 查找算法 (类似于 std::find)
│   │   ├── transform.go   # 变换算法 (类似于 std::transform)
│   │   └── for_each.go    # for_each 算法
│   └── utils/             # 工具类和辅助函数
│       └── helpers.go     # 辅助函数，如比较器和通用函数
├── tests/                 # 测试目录
│   ├── vector_test.go     # vector 容器的单元测试
│   ├── list_test.go       # list 容器的单元测试
│   ├── map_test.go        # map 容器的单元测试
│   ├── sort_test.go       # sort 算法的测试
│   └── find_test.go       # find 算法的测试
├── README.md              # 项目说明文件
└── go.mod                 # Go 模块文件 (用于管理依赖)
```





# Go 语言模拟实现 C++ STL

## 项目简介

> 该项目旨在使用 Go 语言模拟实现 C++ 标准模板库（STL）中的常用数据结构和算法。通过重现 C++ STL 中的容器（如 `vector`、`list`、`map`）以及相关算法库，我将尝试深入使用 Go 语言中的泛型、垃圾回收机制以及语言特性（如：没有运算符重载）的影响，比较两种语言在性能、内存管理和易用性方面的差异。

## 项目动机

这个项目的动机来源于以下几点：

- **深入学习 Go 语言**：通过实现复杂的通用容器和算法库，深入理解 Go 的泛型机制和其他语言特性。
- **比较 Go 与 C++**：通过模拟 STL 来探讨 Go 与 C++ 在实现类似功能时的优缺点，尤其是在性能和内存管理方面的差异。
- **编程练习**：通过该项目提高自己在 Go 语言开发中的设计和实现能力，尤其是在系统级别开发中的表现。

## 技术难点

> 该难点由GPT4o所归纳所得！

### 1. **容器的实现**

Go 没有像 C++ 那样的泛型编程支持，直到 Go 1.18 引入了泛型（Type Parameters），这给实现通用容器带来了很大便利。在此之前，Go 语言的容器多依赖于接口和类型断言，缺少编译时的类型检查。

- **Go 泛型 vs C++ 模板**：Go 的泛型和 C++ 的模板机制虽然功能上类似，但还是有所不同。C++ 的模板可以支持多种元编程技巧，而 Go 的泛型则更加简洁。实现 STL 风格的容器，如 `vector`、`list`、`map`、`set`，在引入了泛型之后会相对简单，可以让我们定义容器支持不同的数据类型。不过，仍需要注意 Go 泛型与 C++ 模板机制的差异，特别是在性能和语法上的区别。
- **性能优化**：C++ 中 STL 容器有很多针对性能的优化，尤其是内存管理和迭代器。在 Go 中，自动垃圾回收机制使得内存管理和释放更加简单，但这也意味着失去了 C++ 中的一些精细化控制权，这可能导致性能问题，尤其是需要高性能的场景下。

### 2. **迭代器的实现**

Go 没有像 C++ 那样的明确迭代器概念，也没有对运算符重载的支持（例如，`++` 迭代器的操作）。但可以通过 Go 的接口机制来模拟迭代器功能。

- **接口的使用**：在 Go 中可以通过定义接口来模拟 C++ 中迭代器的行为，例如通过 `Next()` 方法来访问下一个元素，或者通过 `HasNext()` 判断是否还有更多元素。这种实现虽然不如 C++ STL 中的迭代器灵活（因为 Go 不支持运算符重载等），但可以实现类似的功能。
- **遍历机制**：Go 本身提供了类似 `range` 的遍历机制，虽然它不是迭代器，但在很多场景下可以替代 STL 迭代器的功能。可以将 Go 的 `range` 和自己定义的迭代器结合起来使用，提供一定的灵活性。

### 3. **算法库的实现**

C++ STL 中有很多算法（如排序、查找、变换等），这些算法在 STL 中是基于迭代器的。在 Go 中，由于语言没有直接的运算符重载和迭代器概念，算法的实现需要调整。

- **函数式编程风格**：Go 倾向于使用函数式编程的风格。可以通过高阶函数（如 Go 中的 `func` 类型）来实现类似 C++ STL 中的 `for_each`、`transform` 等功能。
- **标准库中的支持**：Go 的标准库已经提供了很多常用算法（比如 `sort`），但也可以根据需求自行实现其他算法。不过需要注意的是，由于 Go 没有像 C++ 那样的底层内存控制机制，可能在某些性能要求很高的场景中，需要特别关注效率问题。

### 4. **内存管理**

C++ 中的 STL 在实现容器时高度依赖手动的内存管理（`new`、`delete` 等），而 Go 则采用自动垃圾回收机制。这带来了一些设计和实现上的差异。

- **自动垃圾回收**：Go 的自动垃圾回收会减少内存管理负担，但在高性能的应用中，垃圾回收的延迟可能会成为瓶颈。因此，在实现类似 C++ STL 的容器时，可能需要关注内存分配和垃圾回收的频率，优化性能。
- **值类型和引用类型**：Go 中的容器（如 `slice`、`map`）通常是基于引用类型的，而 C++ 中 STL 容器则可以灵活地使用值类型和指针类型。这会影响的容器设计和实现方式。





